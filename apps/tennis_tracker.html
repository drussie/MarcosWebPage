<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tennis Score & Stats Tracker</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .shadow-soft { box-shadow: 0 8px 30px rgba(0,0,0,.08); }
    .grid-auto { display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap: .75rem; }
    .kbd { background:#f1f5f9; border:1px solid #e2e8f0; border-radius:.375rem; padding:.0625rem .375rem; font-size:.75rem; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-4 md:p-6 lg:p-8">
    <header class="mb-6 flex items-start md:items-center justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">ðŸŽ¾ Tennis Score & Stats Tracker</h1>
        <p class="text-slate-600">Track score, point-by-point outcomes, and rich stats for both players. Data auto-saves to this browser.</p>
      </div>
      <div class="flex items-center gap-2">
        <button id="btnExportCSV" type="button" class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm text-sm">Export CSV</button>
        <button id="btnExportJSON" type="button" class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm text-sm">Export JSON</button>
        <label class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm text-sm cursor-pointer">
          Import JSON
          <input id="inputImportJSON" type="file" accept="application/json" class="hidden"/>
        </label>
      </div>
    </header>

    <!-- Match Setup -->
    <section class="mb-6 bg-white border rounded-2xl shadow-sm p-4 md:p-6">
      <div class="grid md:grid-cols-3 gap-4">
        <div>
          <label class="block text-sm font-medium">Player 1 name</label>
          <input id="p0name" class="mt-1 w-full px-3 py-2 rounded-xl border" placeholder="Player 1"/>
        </div>
        <div>
          <label class="block text-sm font-medium">Player 2 name</label>
          <input id="p1name" class="mt-1 w-full px-3 py-2 rounded-xl border" placeholder="Player 2"/>
        </div>
        <div>
          <label class="block text-sm font-medium">Format</label>
          <div class="mt-1 flex flex-wrap items-center gap-3 text-sm">
            <label class="flex items-center gap-2" id="wrap_formatStd">
              <input id="formatStd" type="radio" name="fmt" class="accent-slate-800" checked/>
              Standard
            </label>
            <label class="flex items-center gap-2">
              <input id="formatPro" type="radio" name="fmt" class="accent-slate-800"/>
              Pro Set (to 8, TB at 7â€“7)
            </label>
            <label class="flex items-center gap-2">
              <input id="formatShort" type="radio" name="fmt" class="accent-slate-800"/>
              Short Sets (to 4; TB at 3â€“3; Set 3 = TB10)
            </label>
          </div>

          <div id="stdOpts" class="mt-3 flex flex-wrap items-center gap-3 text-sm">
            <label class="flex items-center gap-2">
              Best of
              <select id="bestOf" class="px-2 py-1 rounded-lg border">
                <option value="3" selected>3</option>
                <option value="5">5</option>
              </select>
              sets
            </label>
            <label class="flex items-center gap-2" id="wrap_tba66">
              <input id="tba66" type="checkbox" class="accent-slate-800" checked/>
              Tiebreak at 6â€“6
            </label>
            <label class="flex items-center gap-2" id="wrap_finalSetTB">
              <input id="finalSetTB" type="checkbox" class="accent-slate-800" checked/>
              Final set uses TB
            </label>
          </div>
        </div>
      </div>

      <div class="mt-4 flex flex-wrap items-center gap-3">
        <div class="text-sm">Server:</div>
        <label class="flex items-center gap-2 text-sm">
          <input type="radio" name="server" id="server0" class="accent-slate-800"/> <span id="server0lbl">Player 1</span>
        </label>
        <label class="flex items-center gap-2 text-sm">
          <input type="radio" name="server" id="server1" class="accent-slate-800"/> <span id="server1lbl">Player 2</span>
        </label>
        <button id="btnNewMatch" type="button" class="ml-auto px-3 py-2 rounded-xl bg-rose-600 text-white hover:bg-rose-700 text-sm">New match / Reset</button>
        <button id="btnUndo" type="button" class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 text-sm">Undo last point</button>
      </div>

      <!-- Seed starting score -->
      <div class="mt-4">
        <button id="btnToggleSeed" type="button" class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 text-sm">Start at specific score</button>
        <div id="seedPanel" class="mt-3 hidden border rounded-xl p-3 bg-slate-50">
          <div class="text-sm font-medium mb-2">Starting score</div>
          <label class="block text-sm">Completed sets (comma-separated, e.g., <em>6-4, 3-6</em>)</label>
          <input id="seedSets" class="mt-1 w-full px-3 py-2 rounded-xl border" placeholder="e.g., 6-4, 3-6"/>
          <div class="grid grid-cols-2 gap-3 mt-3">
            <div>
              <label class="block text-sm">Current set games â€” <span id="seedP0">Player 1</span></label>
              <input id="seedGames0" type="number" min="0" class="mt-1 w-full px-3 py-2 rounded-xl border" value="0"/>
            </div>
            <div>
              <label class="block text-sm">Current set games â€” <span id="seedP1">Player 2</span></label>
              <input id="seedGames1" type="number" min="0" class="mt-1 w-full px-3 py-2 rounded-xl border" value="0"/>
            </div>
          </div>
          <label class="inline-flex items-center gap-2 mt-3 text-sm"><input type="checkbox" id="seedInTB" class="accent-slate-800"> In tiebreak</label>
          <div class="grid grid-cols-2 gap-3 mt-2" id="seedTBRow">
            <div>
              <label class="block text-sm">TB points â€” <span id="seedTBP0">Player 1</span></label>
              <input id="seedTB0" type="number" min="0" class="mt-1 w-full px-3 py-2 rounded-xl border" value="0"/>
            </div>
            <div>
              <label class="block text-sm">TB points â€” <span id="seedTBP1">Player 2</span></label>
              <input id="seedTB1" type="number" min="0" class="mt-1 w-full px-3 py-2 rounded-xl border" value="0"/>
            </div>
          </div>
          <button id="btnApplySeed" type="button" class="mt-3 px-3 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700 text-sm">Apply starting score</button>
          <div class="mt-2 text-xs text-slate-500">
            Tip: Server radio above controls who serves the next point.
          </div>
        </div>
      </div>
    </section>

    <!-- Scoreboard -->
    <section class="mb-6 grid lg:grid-cols-2 gap-6">
      <div class="bg-white border rounded-2xl shadow-sm p-4 md:p-6">
        <h2 class="font-semibold mb-3">Scoreboard</h2>
        <div id="scoreboard" class="overflow-x-auto"></div>
        <div class="mt-3 text-sm text-slate-600" id="scoreHints"></div>
      </div>

      <!-- Stats summary -->
      <div class="bg-white border rounded-2xl shadow-sm p-4 md:p-6">
        <h2 class="font-semibold mb-3">Quick Stats</h2>
        <div id="quickStats" class="grid md:grid-cols-2 gap-4"></div>
      </div>
    </section>

    <!-- Point Entry -->
    <section class="mb-6 bg-white border rounded-2xl shadow-sm p-4 md:p-6">
      <h2 class="font-semibold mb-4">Record a Point</h2>
      <form id="pointForm" class="grid md:grid-cols-2 gap-6">
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium">Server for this point</label>
            <div class="mt-2 flex flex-wrap items-center gap-4 text-sm">
              <label class="flex items-center gap-2">
                <input type="radio" name="pf_server" value="0" class="accent-slate-800"/> <span id="pf_server0">Player 1</span>
              </label>
              <label class="flex items-center gap-2">
                <input type="radio" name="pf_server" value="1" class="accent-slate-800"/> <span id="pf_server1">Player 2</span>
              </label>
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium">Serve result</label>
            <div class="mt-2 flex flex-wrap gap-4 text-sm">
              <label class="inline-flex items-center gap-2">
                <input type="radio" name="serveResult" value="1stin" class="accent-slate-800" checked>
                1st in
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="radio" name="serveResult" value="1stout_2ndin" class="accent-slate-800">
                1st out â†’ 2nd in
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="radio" name="serveResult" value="df" class="accent-slate-800">
                Double fault
              </label>
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium">Point ended by</label>
            <div class="mt-1 grid grid-cols-2 gap-2 text-sm">
              <label class="flex items-center gap-2">
                <input type="radio" name="endType" value="winner" class="accent-slate-800" checked/>
                Winner
              </label>
              <label class="flex items-center gap-2">
                <input type="radio" name="endType" value="error" class="accent-slate-800"/>
                Error
              </label>
            </div>
          </div>

          <div class="grid grid-cols-2 gap-3">
            <div>
              <label class="block text-sm font-medium">
                <span id="byWhichLabel">By which player?</span>
              </label>
              <select name="byPlayer" class="mt-1 w-full px-3 py-2 rounded-xl border">
                <option value="0" id="byP0">Player 1</option>
                <option value="1" id="byP1">Player 2</option>
              </select>
              <div id="pointWinnerPreview" class="mt-1 text-xs text-slate-500"></div>
            </div>
            <div>
              <label class="block text-sm font-medium">Category</label>
              <select name="category" class="mt-1 w-full px-3 py-2 rounded-xl border">
                <option value="fh">FH</option>
                <option value="bh">BH</option>
                <option value="serve">Serve</option>
                <option value="fhv">FHV</option>
                <option value="bhv">BHV</option>
                <option value="oh">OH</option>
              </select>
            </div>
          </div>

          <div id="forcedWrap" class="hidden">
            <label class="inline-flex items-center gap-2 text-sm">
              <input type="checkbox" name="forced" class="accent-slate-800"/> Forced error
            </label>
          </div>

          <div>
            <label class="block text-sm font-medium">Comment (optional)</label>
            <textarea name="comment" rows="2" class="mt-1 w-full px-3 py-2 rounded-xl border" placeholder="e.g., long rally; P1 drop-shot winner"></textarea>
          </div>
          <div class="flex items-center gap-3">
            <button class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-700 text-white font-medium" type="submit">Record point</button>
            <button id="btnClearComment" type="button" class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 text-sm">Clear</button>
          </div>
        </div>

        <div>
          <div class="text-sm text-slate-600">Tips</div>
          <ul class="mt-2 text-sm list-disc pl-5 space-y-1 text-slate-700">
            <li>Use <em>Serve â†’ Double fault</em> for DF; returner automatically wins the point.</li>
            <li>For aces/service winners, choose <em>Winner</em> by the server with category <em>Serve</em>.</li>
            <li>First-serve% is computed from service points: 1st-in / attempts.</li>
            <li>Use <em>Undo</em> if you mis-tap. Everything is saved locally and can be exported.</li>
          </ul>
          <div class="mt-4 p-3 rounded-xl bg-slate-50 border text-xs text-slate-600" id="lastPoint"></div>
        </div>
      </form>
    </section>

    <!-- Detailed Stats -->
    <section class="mb-8 bg-white border rounded-2xl shadow-sm p-4 md:p-6">
      <h2 class="font-semibold mb-4">Detailed Stats</h2>
      <div id="detailedStats" class="grid md:grid-cols-2 gap-6"></div>
    </section>

    <!-- Point Log -->
    <section class="mb-8 bg-white border rounded-2xl shadow-sm p-4 md:p-6">
      <h2 class="font-semibold mb-4">Point Log & Comments</h2>
      <div id="pointLog" class="space-y-2"></div>
    </section>

    <!-- End of Match Comments -->
    <section class="mb-16 bg-white border rounded-2xl shadow-sm p-4 md:p-6">
      <h2 class="font-semibold mb-3">End of Match Comments</h2>
      <textarea id="matchComments" rows="3" class="mt-1 w-full px-3 py-2 rounded-xl border" placeholder="Add final thoughts, highlights, or notes after the match ends..."></textarea>
      <div id="matchCommentsHint" class="text-xs text-slate-500 mt-2">Available after the match ends.</div>
    </section>
  </div>

  <script>
  // ---------- Safety guard: prevent accidental submits ----------
  document.querySelectorAll('button:not([type])').forEach(b => b.type = 'button');
  window.addEventListener('submit', (e) => {
    if (e.target && e.target.id !== 'pointForm') e.preventDefault();
  }, true);

  // ---------- Utilities ----------
  const deepClone = (o) => JSON.parse(JSON.stringify(o));
  const pct = (num, den) => den ? (100 * num / den) : 0;
  const asScore = (gp) => gp===0?"0":gp===1?"15":gp===2?"30":gp===3?"40":gp===4?"Ad":"";

  // ---------- State ----------
  const LS_KEY = 'tennisTrackerState_V4';
  let undoStack = [];

  // Track if the user has manually adjusted specific fields (prevents auto-overwrite)
  const userEdited = { byPlayer: false, category: false };

  const emptyStats = () => ({
    firstServe: {attempts:0, in:0},
    aces: 0,
    doubleFaults: 0,
    winners: { fh:0, bh:0, serve:0, fhv:0, bhv:0, oh:0 },
    errors:  { fh:0, bh:0, serve:0, fhv:0, bhv:0, oh:0 },
    forcedErrors:  { fh:0, bh:0, serve:0, fhv:0, bhv:0, oh:0 },
    pointsWon: 0,
    servicePointsWon: 0,
    servicePointsPlayed: 0,
    returnPointsWon: 0,
    returnPointsPlayed: 0,
    serviceGamesPlayed: 0,
    serviceGamesHeld: 0,
    returnGamesPlayed: 0,
    breaks: 0,
    // Break point stats
    bpEarned: 0, bpConverted: 0,   // returner side
    bpFaced: 0,  bpSaved: 0        // server side
  });

  const newMatchState = () => ({
    players: [ { name: 'Player 1', stats: emptyStats() }, { name: 'Player 2', stats: emptyStats() } ],
    settings: { bestOf: 3, tiebreakAtSixSix: true, finalSetTB: true, format: 'standard' }, // standard|pro|short
    server: 0,
    sets: [ { games: [0,0], tiebreak: false, tbPoints: [0,0] } ],
    gamePoints: [0,0],
    history: [],
    matchComments: ''
  });

  function saveState() { localStorage.setItem(LS_KEY, JSON.stringify(state)); }
  function loadState() { try { return JSON.parse(localStorage.getItem(LS_KEY)); } catch(e){ return null; } }

  let state = loadState() || newMatchState();
  function pushUndo() { undoStack.push(JSON.stringify(state)); if (undoStack.length>200) undoStack.shift(); }
  function undo() {
    if (!undoStack.length) return;
    const prev = undoStack.pop();
    state = JSON.parse(prev);
    renderAll(); saveState();
  }

  // ---------- Helpers ----------
  function currentSet() { return state.sets[state.sets.length-1]; }
  function getBestOfUsed() { return state.settings.format==='pro' ? 1 : (state.settings.format==='short' ? 3 : state.settings.bestOf); }
  function setsNeededToWin() { const bo = getBestOfUsed(); return Math.floor(bo/2)+1; }
  function setsWonBy() {
    const w=[0,0]; for (const s of state.sets) { if (s.games[0]>s.games[1]) w[0]++; else if (s.games[1]>s.games[0]) w[1]++; } return w;
  }
  function isMatchOver() {
    const sw = setsWonBy(); const need = setsNeededToWin(); return (sw[0] >= need || sw[1] >= need);
  }
  function getTBTargetForCurrentSet() {
    const set = currentSet(); if (set.tbTo) return set.tbTo;
    if (state.settings.format==='short' && state.sets.length===3) return 10; return 7;
  }
  function isBreakPoint(serverIdx) {
    const recv = 1 - serverIdx, gpS = state.gamePoints[serverIdx], gpR = state.gamePoints[recv], set = currentSet();
    if (set.tiebreak) return false;
    return (gpR===3 && gpS<=2) || (gpR===4 && gpS===3); // 30-40, 15-40, 0-40, Ad-Receiver
  }

  // Clear labeling + preview for winner
  function getDeclaredWinnerFromForm(form){
    const sEl = form.querySelector('input[name="pf_server"]:checked');
    const sIdx = sEl ? +sEl.value : 0;
    const endEl = form.querySelector('input[name="endType"]:checked');
    const endType = endEl ? endEl.value : 'winner';
    const srEl = form.querySelector('input[name="serveResult"]:checked') ||
                 form.querySelector('select[name="serveResult"]');
    const serveResult = srEl ? srEl.value : '1stin';
    if (serveResult === 'df') return 1 - sIdx; // DF â†’ returner
    const bySel = form.querySelector('select[name="byPlayer"]');
    const by = bySel ? +bySel.value : sIdx;
    return endType === 'winner' ? by : (1 - by);
  }
  function updateByWhichLabel(){
    const form = document.getElementById('pointForm'); if (!form) return;
    const endEl = form.querySelector('input[name="endType"]:checked');
    const lbl = document.getElementById('byWhichLabel'); if (!lbl) return;
    const endType = endEl ? endEl.value : 'winner';
    lbl.textContent = endType === 'winner' ? 'Who hit the winner?' : 'Who made the error?';
  }
  function updatePointWinnerPreview(){
    const form = document.getElementById('pointForm'); const prev = document.getElementById('pointWinnerPreview');
    if (!form || !prev) return;
    const w = getDeclaredWinnerFromForm(form);
    const name = (state && state.players && state.players[w]) ? state.players[w].name : (w===0?'Player 1':'Player 2');
    prev.textContent = `Point goes to: ${name}`;
  }

  // ---------- Scoring Logic ----------
  function pointTo(playerIdx) {
    const opp = 1 - playerIdx, set = currentSet();
    if (set.tiebreak) {
      set.tbPoints[playerIdx]++;
      const w = set.tbPoints[playerIdx], l = set.tbPoints[opp], target = getTBTargetForCurrentSet();
      if (w>=target && (w-l)>=2) { set.games[playerIdx]++; finishSet(playerIdx, true); }
      return;
    }
    const w = state.gamePoints[playerIdx], l = state.gamePoints[opp];
    if (w <= 2) state.gamePoints[playerIdx]++;
    else if (w === 3 && l < 3) gameWonBy(playerIdx);
    else if (w === 3 && l === 3) state.gamePoints[playerIdx] = 4;
    else if (w === 4) gameWonBy(playerIdx);
    else if (l === 4) state.gamePoints[opp] = 3;
  }

  function gameWonBy(playerIdx) {
    const set = currentSet(); set.games[playerIdx]++;
    const server = state.server, returner = 1 - server;
    state.players[server].stats.serviceGamesPlayed++; state.players[returner].stats.returnGamesPlayed++;
    if (playerIdx === server) state.players[server].stats.serviceGamesHeld++; else state.players[returner].stats.breaks++;

    state.gamePoints = [0,0]; state.server = 1 - state.server;

    const w = set.games[playerIdx], l = set.games[1-playerIdx];

    if (state.settings.format === 'pro') {
      if (w===7 && l===7) { set.tiebreak = true; set.tbPoints=[0,0]; set.tbTo=7; return; }
      if (w>=8 && (w-l)>=2) { finishSet(playerIdx, false); }
      return;
    }
    if (state.settings.format === 'short') {
      if (w===3 && l===3) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; return; }
      if (w>=4 && (w-l)>=2) { finishSet(playerIdx, false); }
      return;
    }
    const needTB = (w===6 && l===6 && state.settings.tiebreakAtSixSix && (state.settings.finalSetTB || (state.sets.length < state.settings.bestOf)));
    if (needTB) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; return; }
    if (w>=6 && (w-l)>=2) { finishSet(playerIdx, false); }
  }

  function finishSet(winnerIdx, viaTB) {
    const sw = setsWonBy(), need = setsNeededToWin();
    if (sw[winnerIdx] >= need) {
      const mc = document.getElementById('matchComments'); const hint = document.getElementById('matchCommentsHint');
      if (mc) mc.disabled = false; if (hint) hint.textContent = 'Match finished â€” add your final comments.';
      return;
    }
    if (state.settings.format==='short') {
      const swn = setsWonBy();
      if (swn[0]===1 && swn[1]===1) { state.sets.push({ games:[0,0], tiebreak:true, tbPoints:[0,0], tbTo:10 }); return; }
    }
    state.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0] });
  }

  // ---------- Point Recording ----------
  function recordPoint(formData) {
    const formEl = document.getElementById('pointForm');
    const server = +formData.get('pf_server');
    const serveResult = formData.get('serveResult');
    const endType = formData.get('endType');
    const byPlayer = +formData.get('byPlayer');
    const category = formData.get('category');
    const comment = (formData.get('comment')||'').trim();

    const breakPoint = isBreakPoint(server);
    const inferredWinner = getDeclaredWinnerFromForm(formEl);

    const point = {
      server,
      serve: { firstAttempt: true, firstIn: (serveResult==='1stin'), doubleFault: (serveResult==='df'), secondIn: (serveResult==='1stout_2ndin') },
      outcome: endType,
      byPlayer,
      category,
      forced: endType==='error' ? !!formData.get('forced') : false,
      comment,
      breakPoint,
      timestamp: Date.now()
    };

    if (serveResult==='df') { point.winner = 1 - server; point.doubleFault = true; }
    else { point.winner = inferredWinner; }

    applyPoint(point);
  }

  function applyPoint(point) {
    pushUndo();

    const sIdx = point.server;
    state.players[sIdx].stats.firstServe.attempts++;
    if (point.serve.firstIn) state.players[sIdx].stats.firstServe.in++;

    state.players[sIdx].stats.servicePointsPlayed++;
    state.players[1-sIdx].stats.returnPointsPlayed++;

    const winner = point.winner;

    if (point.breakPoint) {
      const recv = 1 - sIdx;
      state.players[recv].stats.bpEarned++;
      state.players[sIdx].stats.bpFaced++;
    }

    if (point.doubleFault) {
      state.players[sIdx].stats.doubleFaults++;
      state.players[winner].stats.pointsWon++;
      if (winner === sIdx) state.players[sIdx].stats.servicePointsWon++; else state.players[1-sIdx].stats.returnPointsWon++;
      if (point.breakPoint) {
        if (winner !== sIdx) state.players[1-sIdx].stats.bpConverted++; else state.players[sIdx].stats.bpSaved++;
      }
      pointTo(winner); finalizePoint(point); return;
    }

    if (point.outcome==='winner') {
      if (point.category==='serve' && winner===sIdx) state.players[sIdx].stats.aces++;
      state.players[winner].stats.winners[point.category]++;
    } else if (point.outcome==='error') {
      state.players[point.byPlayer].stats.errors[point.category]++;
      if (point.forced) state.players[point.byPlayer].stats.forcedErrors[point.category]++;
    }

    state.players[winner].stats.pointsWon++;
    if (winner === sIdx) state.players[sIdx].stats.servicePointsWon++; else state.players[1-sIdx].stats.returnPointsWon++;

    if (point.breakPoint) {
      if (winner !== sIdx) state.players[1-sIdx].stats.bpConverted++; else state.players[sIdx].stats.bpSaved++;
    }

    pointTo(winner);
    finalizePoint(point);
  }

  function finalizePoint(point) {
    state.history.push(point);
    saveState(); renderAll();

    const n = state.history.length;
    const pName = state.players[point.winner].name;
    const cat = point.category.toUpperCase();
    let sr = point.serve.firstIn ? '1st-in' : (point.serve.secondIn ? '2nd-in' : (point.doubleFault?'DF':'n/a'));
    const bp = point.breakPoint ? ' â€” BP' : '';
    document.getElementById('lastPoint').textContent =
      `#${n}: ${pName} won the point (${point.outcome} â€“ ${cat}; serve: ${sr}${bp})${point.comment?` â€” ${point.comment}`:''}`;

    // Reset only the comment field
    const cEl = document.querySelector('[name="comment"]'); if (cEl) cEl.value = '';

    // Next point: allow sensible defaults again
    userEdited.byPlayer = false;
    userEdited.category = false;
  }

  // ---------- Rendering ----------
  function renderAll() {
    if (!state.settings) state.settings = { format:'standard', bestOf:3, tiebreakAtSixSix:true, finalSetTB:true };
    if (state.settings.format === undefined) state.settings.format = 'standard';

    document.getElementById('formatStd').checked = state.settings.format==='standard';
    document.getElementById('formatPro').checked = state.settings.format==='pro';
    document.getElementById('formatShort').checked = state.settings.format==='short';
    updateFormatUI();

    document.getElementById('p0name').value = state.players[0].name;
    document.getElementById('p1name').value = state.players[1].name;
    document.getElementById('server0lbl').textContent = state.players[0].name;
    document.getElementById('server1lbl').textContent = state.players[1].name;
    document.getElementById('pf_server0').textContent = state.players[0].name;
    document.getElementById('pf_server1').textContent = state.players[1].name;
    const byP0 = document.getElementById('byP0'); const byP1 = document.getElementById('byP1');
    if (byP0) byP0.textContent = state.players[0].name; if (byP1) byP1.textContent = state.players[1].name;

    const seedP0 = document.getElementById('seedP0'); if (seedP0) seedP0.textContent = state.players[0].name;
    const seedP1 = document.getElementById('seedP1'); if (seedP1) seedP1.textContent = state.players[1].name;
    const seedTBP0 = document.getElementById('seedTBP0'); if (seedTBP0) seedTBP0.textContent = state.players[0].name;
    const seedTBP1 = document.getElementById('seedTBP1'); if (seedTBP1) seedTBP1.textContent = state.players[1].name;

    document.getElementById('bestOf').value = String(state.settings.bestOf || 3);
    document.getElementById('tba66').checked = !!state.settings.tiebreakAtSixSix;
    document.getElementById('finalSetTB').checked = !!state.settings.finalSetTB;

    document.getElementById('server0').checked = state.server===0;
    document.getElementById('server1').checked = state.server===1;

    for (const el of document.querySelectorAll('input[name="pf_server"]')) el.checked = (+el.value)===state.server;

    updateDynamicDefaults();
    updateByWhichLabel();
    updatePointWinnerPreview();

    renderScoreboard();
    renderQuickStats();
    renderDetailedStats();
    renderPointLog();

    const mc = document.getElementById('matchComments');
    const hint = document.getElementById('matchCommentsHint');
    if (mc && hint) {
      mc.value = state.matchComments || '';
      const over = isMatchOver();
      mc.disabled = !over;
      hint.textContent = over ? 'Match finished â€” add your final comments.' : 'Available after the match ends.';
    }
  }

  function renderScoreboard() {
    const el = document.getElementById('scoreboard');
    const sets = state.sets;

    let html = '<table class="min-w-full text-sm">';
    html += '<thead><tr>';
    html += '<th class="text-left p-2">Player</th>';
    for (let i=0;i<sets.length;i++) html += `<th class="p-2 text-center border-l">Set ${i+1}</th>`;
    html += `<th class="p-2 text-center border-l">Game</th>`;
    const cs = currentSet(); if (cs.tiebreak) html += `<th class="p-2 text-center border-l">Tiebreak</th>`;
    html += '</tr></thead>';

    const row = (idx) => {
      let r = `<tr class="border-t">`;
      const isServer = state.server===idx ? ' ðŸ”¸' : '';
      r += `<td class="p-2 font-medium">${state.players[idx].name}${isServer}</td>`;
      for (let s of sets) r += `<td class="p-2 text-center border-l">${s.games[idx]}</td>`;
      r += `<td class="p-2 text-center border-l">${asScore(state.gamePoints[idx])}</td>`;
      if (cs.tiebreak) r += `<td class="p-2 text-center border-l">${cs.tbPoints[idx]}</td>`;
      r += '</tr>'; return r;
    };

    html += '<tbody>' + row(0) + row(1) + '</tbody></table>';
    el.innerHTML = html;

    const hints = document.getElementById('scoreHints');
    const sw = setsWonBy();
    if (state.settings.format==='pro') {
      hints.textContent = `Pro set to 8 (TB at 7â€“7). Server marked with ðŸ”¸.`;
    } else if (state.settings.format==='short') {
      hints.textContent = `Short sets to 4 (TB at 3â€“3). If 1â€“1 in sets, deciding match tiebreak to 10. Server marked with ðŸ”¸.`;
    } else {
      const bo = state.settings.bestOf, needToWin = Math.floor(bo/2)+1;
      hints.textContent = `Sets: ${sw[0]}â€“${sw[1]} (first to ${needToWin}). Server marked with ðŸ”¸.`;
    }
  }

  function renderQuickStats() {
    const qs = document.getElementById('quickStats');
    const card = (idx) => {
      const p = state.players[idx];
      const fs = p.stats.firstServe, spw = p.stats.servicePointsWon, spp = p.stats.servicePointsPlayed;
      const rpw = p.stats.returnPointsWon, rpp = p.stats.returnPointsPlayed;
      const holds = p.stats.serviceGamesHeld, sGP = p.stats.serviceGamesPlayed, breaks = p.stats.breaks;
      const bpE = p.stats.bpEarned, bpC = p.stats.bpConverted, bpF = p.stats.bpFaced, bpS = p.stats.bpSaved;
      return `
      <div class="rounded-2xl border p-4">
        <div class="font-semibold mb-1">${p.name}</div>
        <div class="text-xs text-slate-600 mb-3">Points won: <span class="font-medium">${p.stats.pointsWon}</span></div>
        <div class="grid grid-cols-2 gap-3 text-sm">
          <div><div class="text-slate-500">1st Serve%</div><div class="font-medium">${pct(fs.in, fs.attempts).toFixed(1)}%</div></div>
          <div><div class="text-slate-500">Aces</div><div class="font-medium">${p.stats.aces}</div></div>
          <div><div class="text-slate-500">Double Faults</div><div class="font-medium">${p.stats.doubleFaults}</div></div>
          <div><div class="text-slate-500">Hold %</div><div class="font-medium">${pct(holds, sGP).toFixed(1)}% (${holds}/${sGP})</div></div>
          <div><div class="text-slate-500">Srv Pts Won %</div><div class="font-medium">${pct(spw, spp).toFixed(1)}%</div></div>
          <div><div class="text-slate-500">Ret Pts Won %</div><div class="font-medium">${pct(rpw, rpp).toFixed(1)}%</div></div>
          <div><div class="text-slate-500">Breaks</div><div class="font-medium">${breaks}</div></div>
          <div><div class="text-slate-500">Break Points</div><div class="font-medium">${bpC}/${bpE} converted â€¢ saved ${bpS}/${bpF}</div></div>
        </div>
      </div>`;
    };
    qs.innerHTML = card(0) + card(1);
  }

  function renderDetailedStats() {
    const container = document.getElementById('detailedStats');
    const block = (idx) => {
      const p = state.players[idx], W = p.stats.winners, E = p.stats.errors, F = p.stats.forcedErrors;
      const netW = W.fhv + W.bhv + W.oh, netE = E.fhv + E.bhv + E.oh;
      return `
      <div class="rounded-2xl border p-4">
        <div class="font-semibold mb-3">${p.name}</div>
        <div class="grid grid-cols-2 gap-3 text-sm">
          <div>
            <div class="text-slate-500 font-medium mb-1">Winners</div>
            <ul class="space-y-1">
              <li>FH: <span class="font-medium">${W.fh}</span></li>
              <li>BH: <span class="font-medium">${W.bh}</span></li>
              <li>Serve (aces+SW): <span class="font-medium">${W.serve}</span></li>
              <li>FHV: <span class="font-medium">${W.fhv}</span></li>
              <li>BHV: <span class="font-medium">${W.bhv}</span></li>
              <li>OH: <span class="font-medium">${W.oh}</span></li>
              <li class="pt-1 border-t">Net winners: <span class="font-medium">${netW}</span></li>
            </ul>
          </div>
          <div>
            <div class="text-slate-500 font-medium mb-1">Errors</div>
            <ul class="space-y-1">
              <li>FH: <span class="font-medium">${E.fh}</span> <span class="text-xs text-slate-500">(forced ${F.fh})</span></li>
              <li>BH: <span class="font-medium">${E.bh}</span> <span class="text-xs text-slate-500">(forced ${F.bh})</span></li>
              <li>Serve (incl. DF): <span class="font-medium">${E.serve}</span> <span class="text-xs text-slate-500">(forced ${F.serve})</span></li>
              <li>FHV: <span class="font-medium">${E.fhv}</span> <span class="text-xs text-slate-500">(forced ${F.fhv})</span></li>
              <li>BHV: <span class="font-medium">${E.bhv}</span> <span class="text-xs text-slate-500">(forced ${F.bhv})</span></li>
              <li>OH: <span class="font-medium">${E.oh}</span> <span class="text-xs text-slate-500">(forced ${F.oh})</span></li>
              <li class="pt-1 border-t">Net errors: <span class="font-medium">${netE}</span></li>
            </ul>
          </div>
        </div>
      </div>`;
    };
    container.innerHTML = block(0) + block(1);
  }

  function renderPointLog() {
    const el = document.getElementById('pointLog');
    const rows = state.history.map((p, i) => {
      const winner = state.players[p.winner].name;
      const by = state.players[p.byPlayer].name;
      const serveTxt = p.serve.firstIn? '1st-in' : p.serve.secondIn? '2nd-in' : p.doubleFault? 'DF' : 'n/a';
      const cat = p.category.toUpperCase();
      const forced = p.outcome==='error' ? (p.forced? ' (forced)' : ' (unforced)') : '';
      const bp = p.breakPoint ? ' â€¢ BP' : '';
      const c = p.comment? `<div class='text-slate-500 mt-1'>${escapeHtml(p.comment)}</div>` : '';
      return `<div class="p-3 border rounded-xl">
        <div class="text-sm"><span class="text-slate-500">#${i+1}</span> <span class="font-medium">${winner}</span> won â€” ${p.outcome} by ${by} â€¢ ${cat} â€¢ serve ${serveTxt}${forced}${bp}</div>
        ${c}
      </div>`;
    });
    el.innerHTML = rows.join('');
  }

  function escapeHtml(str) { return str.replace(/[&<>"]+/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s])); }

  // ---------- Dynamic defaults for point form (guarded) ----------
  function updateDynamicDefaults() {
    const form = document.getElementById('pointForm'); if (!form) return;

    const sRadio = form.querySelector('input[name="pf_server"]:checked');
    if (!sRadio) return;
    const sIdx = +sRadio.value;
    const rIdx = 1 - sIdx;

    const endTypeEl = form.querySelector('input[name="endType"]:checked');
    const endType = endTypeEl ? endTypeEl.value : 'winner';

    const bySel = form.querySelector('select[name="byPlayer"]');
    const catSel = form.querySelector('select[name="category"]');

    // Apply defaults only if the user hasn't edited these yet
    const byDefault  = (endType === 'winner') ? sIdx : rIdx;
    if (bySel && !userEdited.byPlayer) {
      bySel.value = String(byDefault);
    }

    if (catSel && endType === 'winner' && !userEdited.category) {
      // Suggest "Serve" for winners by default; user can change and it will stick
      catSel.value = 'serve';
    }

    updateByWhichLabel();
    updatePointWinnerPreview();
  }

  function updateFormatUI() {
    const std = document.getElementById('formatStd').checked;
    const pro = document.getElementById('formatPro').checked;
    const sh  = document.getElementById('formatShort').checked;
    const stdOpts = document.getElementById('stdOpts');

    if (std) state.settings.format = 'standard';
    else if (pro) state.settings.format = 'pro';
    else if (sh) state.settings.format = 'short';

    stdOpts.style.opacity = std ? '1' : '0.5';
    for (const sel of stdOpts.querySelectorAll('select, input[type="checkbox"]')) sel.disabled = !std;
  }

  // ---------- Exports ----------
  function download(filename, text) {
    const a = document.createElement('a');
    a.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    a.setAttribute('download', filename);
    a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a);
  }
  function exportJSON() { download('tennis_match.json', JSON.stringify(state, null, 2)); }

  function exportCSV() {
    const lines = [];
    lines.push(['point','server','firstServeIn','secondServeIn','doubleFault','winner','byPlayer','outcome','category','forced','breakPoint','comment','setIdx','gamesP0','gamesP1','tb','tbP0','tbP1'].join(','));
    const sim = newMatchState();
    sim.players[0].name = state.players[0].name; sim.players[1].name = state.players[1].name;
    sim.settings = deepClone(state.settings);
    sim.server = state.history.length ? state.history[0].server : state.server;

    for (let i=0;i<state.history.length;i++) {
      const p = state.history[i];
      const cs = sim.sets[sim.sets.length-1];
      lines.push([
        i+1,
        sim.players[p.server].name,
        p.serve.firstIn?1:0,
        p.serve.secondIn?1:0,
        p.doubleFault?1:0,
        state.players[p.winner].name,
        state.players[p.byPlayer].name,
        p.outcome,
        p.category,
        p.outcome==='error'?(p.forced?1:0):'',
        p.breakPoint?1:0,
        '"'+(p.comment||'').replace(/"/g,'""')+'"',
        sim.sets.length,
        cs.games[0], cs.games[1],
        cs.tiebreak?1:0,
        cs.tbPoints[0], cs.tbPoints[1]
      ].join(','));
      applyPointSim(sim, p);
    }
    download('tennis_points.csv', lines.join('\n'));
  }

  function applyPointSim(sim, point) {
    sim.players[point.server].stats.firstServe.attempts++;
    if (point.serve.firstIn) sim.players[point.server].stats.firstServe.in++;

    const winner = point.doubleFault ? (1 - point.server) : point.winner;
    const set = sim.sets[sim.sets.length-1];
    function tbTarget(){ if (set.tbTo) return set.tbTo; if (sim.settings.format==='short' && sim.sets.length===3) return 10; return 7; }

    const pointTo = (playerIdx) => {
      const opp = 1 - playerIdx;
      if (set.tiebreak) {
        set.tbPoints[playerIdx]++;
        const w = set.tbPoints[playerIdx], l = set.tbPoints[opp], target = tbTarget();
        if (w>=target && (w-l)>=2) {
          set.games[playerIdx]++;
          const need = (sim.settings.format==='pro'?1:(sim.settings.format==='short'?3:sim.settings.bestOf));
          const sw = (function(){ const w=[0,0]; for (const s of sim.sets) { if (s.games[0]>s.games[1]) w[0]++; else if (s.games[1]>s.games[0]) w[1]++; } return w; })();
          if (sw[playerIdx] >= Math.floor(need/2)+1) return;
          if (sim.settings.format==='short') {
            const swn = (function(){ const w=[0,0]; for (const s of sim.sets) { if (s.games[0]>s.games[1]) w[0]++; else if (s.games[1]>s.games[0]) w[1]++; } return w; })();
            if (swn[0]===1 && swn[1]===1) { sim.sets.push({ games:[0,0], tiebreak:true, tbPoints:[0,0], tbTo:10 }); return; }
          }
          sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0] });
        }
      } else {
        const w = sim.gamePoints[playerIdx], l = sim.gamePoints[opp];
        if (w <= 2) sim.gamePoints[playerIdx]++;
        else if (w===3 && l<3) {
          set.games[playerIdx]++; sim.gamePoints=[0,0]; sim.server = 1 - sim.server;
          const gw = set.games[playerIdx], gl = set.games[opp];
          if (sim.settings.format==='pro') {
            if (gw===7 && gl===7) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; }
            else if (gw>=8 && (gw-gl)>=2) { sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0]}); }
          } else if (sim.settings.format==='short') {
            if (gw===3 && gl===3) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; }
            else if (gw>=4 && (gw-gl)>=2) {
              const swn = (function(){ const w=[0,0]; for (const s of sim.sets) { if (s.games[0]>s.games[1]) w[0]++; else if (s.games[1]>s.games[0]) w[1]++; } return w; })();
              if (!(swn[playerIdx] >= 2)) {
                if (swn[0]===1 && swn[1]===1) sim.sets.push({ games:[0,0], tiebreak:true, tbPoints:[0,0], tbTo:10 });
                else sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0]});
              }
            }
          } else {
            if (gw===6 && gl===6 && sim.settings.tiebreakAtSixSix) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; }
            else if (gw>=6 && (gw-gl)>=2) { sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0]}); }
          }
        } else if (w===3 && l===3) sim.gamePoints[playerIdx]=4;
        else if (w===4) {
          set.games[playerIdx]++; sim.gamePoints=[0,0]; sim.server = 1 - sim.server;
          const gw = set.games[playerIdx], gl = set.games[opp];
          if (sim.settings.format==='pro') {
            if (gw===7 && gl===7) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; }
            else if (gw>=8 && (gw-gl)>=2) { sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0]}); }
          } else if (sim.settings.format==='short') {
            if (gw===3 && gl===3) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; }
            else if (gw>=4 && (gw-gl)>=2) {
              const swn2 = (function(){ const w=[0,0]; for (const s of sim.sets) { if (s.games[0]>s.games[1]) w[0]++; else if (s.games[1]>s.games[0]) w[1]++; } return w; })();
              if (!(swn2[playerIdx] >= 2)) {
                if (swn2[0]===1 && swn2[1]===1)
                  sim.sets.push({ games:[0,0], tiebreak:true, tbPoints:[0,0], tbTo:10 }); /* <- fixed ':' */
                else
                  sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0]});
              }
            }
          } else {
            if (gw===6 && gl===6 && sim.settings.tiebreakAtSixSix) { set.tiebreak=true; set.tbPoints=[0,0]; set.tbTo=7; }
            else if (gw>=6 && (gw-gl)>=2) { sim.sets.push({ games:[0,0], tiebreak:false, tbPoints:[0,0]}); }
          }
        } else if (l===4) sim.gamePoints[opp]=3;
      }
    };
    pointTo(winner);
  }

  // ---------- Events ----------
  document.getElementById('btnUndo').addEventListener('click', () => undo());
  document.getElementById('btnNewMatch').addEventListener('click', () => {
    if (!confirm('Start a new match and clear current data?')) return;
    pushUndo(); state = newMatchState(); saveState(); renderAll();
  });

  document.getElementById('p0name').addEventListener('input', (e)=>{ state.players[0].name=e.target.value; saveState(); renderAll(); });
  document.getElementById('p1name').addEventListener('input', (e)=>{ state.players[1].name=e.target.value; saveState(); renderAll(); });

  document.getElementById('formatStd').addEventListener('change', ()=>{ updateFormatUI(); saveState(); renderAll(); });
  document.getElementById('formatPro').addEventListener('change', ()=>{ updateFormatUI(); saveState(); renderAll(); });
  document.getElementById('formatShort').addEventListener('change', ()=>{ updateFormatUI(); saveState(); renderAll(); });

  document.getElementById('bestOf').addEventListener('change', (e)=>{
    state.settings.bestOf=+e.target.value; state.settings.format='standard'; saveState(); renderAll();
  });
  document.getElementById('tba66').addEventListener('change', (e)=>{ state.settings.tiebreakAtSixSix=!!e.target.checked; saveState(); renderAll(); });
  document.getElementById('finalSetTB').addEventListener('change', (e)=>{ state.settings.finalSetTB=!!e.target.checked; saveState(); renderAll(); });

  document.getElementById('server0').addEventListener('change', ()=>{ state.server=0; saveState(); renderAll(); });
  document.getElementById('server1').addEventListener('change', ()=>{ state.server=1; saveState(); renderAll(); });

  // Seed panel
  document.getElementById('btnToggleSeed').addEventListener('click', ()=>{
    document.getElementById('seedPanel').classList.toggle('hidden');
  });
  document.getElementById('seedInTB').addEventListener('change', (e)=>{
    document.getElementById('seedTBRow').classList.toggle('hidden', !e.target.checked);
  });
  document.getElementById('btnApplySeed').addEventListener('click', ()=>{
    function parseSets(txt){
      const out=[]; (txt||'').split(',').map(s=>s.trim()).filter(Boolean).forEach(p=>{
        const m = p.match(/^(\d+)\s*[-â€“]\s*(\d+)$/); if (m){ out.push([+m[1], +m[2]]); }
      }); return out;
    }
    const completed = parseSets(document.getElementById('seedSets').value);
    const g0 = +document.getElementById('seedGames0').value || 0;
    const g1 = +document.getElementById('seedGames1').value || 0;
    const inTB = !!document.getElementById('seedInTB').checked;
    const tb0 = +document.getElementById('seedTB0').value || 0;
    const tb1 = +document.getElementById('seedTB1').value || 0;

    pushUndo();
    state.sets = completed.map(g=>({ games:[g[0], g[1]], tiebreak:false, tbPoints:[0,0] }));
    state.sets.push({ games:[g0,g1], tiebreak:inTB, tbPoints:[tb0,tb1] });
    delete state.sets[state.sets.length-1].tbTo;
    state.gamePoints = [0,0];
    saveState(); renderAll(); alert('Starting score applied.');
  });

  // Point form change handling (guarded)
  document.getElementById('pointForm').addEventListener('change', (e)=>{
    // Show/hide forced error toggle
    if (e.target.name==='endType') {
      document.getElementById('forcedWrap').classList.toggle('hidden', e.target.value!=='error');
    }

    // If the defaults' drivers changed, allow defaults to reapply
    if (e.target.name==='endType' || e.target.name==='pf_server') {
      userEdited.byPlayer = false;
      userEdited.category = false;
    }

    updateDynamicDefaults();
  });

  // Mark fields as explicitly edited by the user
  document.querySelector('select[name="byPlayer"]').addEventListener('change', ()=>{
    userEdited.byPlayer = true;
    updatePointWinnerPreview();
  });
  document.querySelector('select[name="category"]').addEventListener('change', ()=>{
    userEdited.category = true;
  });

  document.getElementById('pointForm').addEventListener('submit', (e)=>{
    e.preventDefault(); const fd = new FormData(e.target); recordPoint(fd);
  });
  document.getElementById('btnClearComment').addEventListener('click', ()=>{
    const c = document.querySelector('[name="comment"]'); if (c) c.value='';
  });

  // Export / Import
  document.getElementById('btnExportCSV').addEventListener('click', exportCSV);
  document.getElementById('btnExportJSON').addEventListener('click', exportJSON);
  document.getElementById('inputImportJSON').addEventListener('change', async (e)=>{
    const file = e.target.files[0]; if (!file) return;
    try {
      const txt = await file.text(); const obj = JSON.parse(txt);
      if (!obj || !obj.players || !obj.sets) throw new Error('Invalid file.');
      pushUndo(); state = obj; saveState(); renderAll(); alert('Import successful.');
    } catch(err) { alert('Import failed: '+err.message); }
    finally { e.target.value = ''; }
  });

  // End-of-match comments save-on-input
  document.getElementById('matchComments').addEventListener('input', (e)=>{
    state.matchComments = e.target.value; saveState();
  });

  // Initial render
  renderAll();
  </script>
</body>
</html>
